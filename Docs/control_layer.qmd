# Control Layer Implementation

The Control Layer forms the decision-making core of RobotZero, managing the robot's behaviour in response to sensor inputs and track conditions. This layer translates raw sensor data into actionable controls, implementing the robot's core line-following logic while managing special track features like markers and intersections. Operating between the Hardware Interface Layer and the Main Control system, it ensures smooth and predictable robot behaviour under varying conditions.

>**TODO**: This version of CourseMarkers has not been run yet. At this stage of development (Dec/2024), this code is purely theoretical and REQUIRES EXTENSIVE TESTING. This implementation represents our current design approach but has not been validated in real-world conditions.

The `CourseMarkers` class represents the primary control component, implementing track feature detection and corresponding behaviour adjustments. This class processes marker sensor data to identify track features and manages the robot's response to these features, including speed changes, lap counting, and precision mode transitions. Through its state machine implementation, it ensures reliable detection of track features and smooth transitions between different operating modes.

The `ProfileManager` class complements the control system by managing operation profiles and parameters based on the current debug level. When `DEBUG_LEVEL` is greater than `0`, it provides different speed and control parameter sets optimized for either analysis (`DEBUG_LEVEL = 1`) or high-speed performance (`DEBUG_LEVEL = 2`). This class enables the robot to maintain consistent control logic while operating under different performance requirements, making it an essential component for both development and competition scenarios.

## CourseMarkers Implementation (CourseMakers.h / CourseMakers.cpp)

The CourseMarkers class manages track feature detection and robot behaviour through an optimized state-based approach:

```cpp
class CourseMarkers {
private:
    // Timing control
    static uint32_t lastReadTime;
    
    // State variables
    static int speed;
    static int lastMarkerState;
    static int previousMarkerState;
    static int oldMarkerState;
    static int currentMarkerState;
    static int16_t leftMarkerDetected;   
    static int16_t rightMarkerDetected;  

    // Speed control variables
    static bool isTurning;
    static bool isExitingTurn;
    static uint8_t boostCountdown;

    // Timers for precise control
    static Timer stopTimer;
    static Timer slowdownTimer;
};
```

A key innovation in the marker detection system is its time-controlled operation:

```cpp
void CourseMarkers::readCourseMarkers() {
    // Time-controlled reading
    uint32_t currentTime = millis();
    if (currentTime - lastReadTime < MARKER_READ_INTERVAL) {
        return;
    }
    lastReadTime = currentTime;

    // Optimized marker reading with direct state calculation
    bool leftDetected = analogRead(PIN_MARKER_LEFT) <= MARKER_DETECTION_THRESHOLD;
    bool rightDetected = analogRead(PIN_MARKER_RIGHT) <= MARKER_DETECTION_THRESHOLD;
    currentMarkerState = (leftDetected << 1) | rightDetected;

    // LED feedback only when needed
    digitalWrite(PIN_STATUS_LED, leftDetected || rightDetected);
}
```

The speed control system implements an optimized decision tree for quick response:

```cpp
int CourseMarkers::speedControl(int error) {
    // Early curve detection
    bool curve_detected = abs(error) > TURN_THRESHOLD;
    if (curve_detected) {
        isTurning = true;
        isExitingTurn = false;
        return TURN_SPEED;
    }

    bool straight_detected = abs(error) < STRAIGHT_THRESHOLD;
    int target_speed;

    if (straight_detected) {
        if (isTurning) {
            isExitingTurn = true;
            boostCountdown = BOOST_DURATION;
        }
        isTurning = false;
        target_speed = isPrecisionMode ? SPEED_SLOW : BASE_FAST;
    }
    else {
        target_speed = map(abs(error),
            STRAIGHT_THRESHOLD,
            TURN_THRESHOLD,
            (isPrecisionMode ? SPEED_SLOW : BASE_FAST),
            TURN_SPEED);
    }

    // Optimized speed adjustment
    if (isExitingTurn && boostCountdown > 0 && !isPrecisionMode) {
        target_speed = min(255, target_speed + BOOST_INCREMENT);
        boostCountdown--;
    }

    int step = (target_speed > currentSpeed) ? ACCELERATION_STEP : BRAKE_STEP;
    if (abs(target_speed - currentSpeed) <= step) {
        currentSpeed = target_speed;
    }
    else {
        currentSpeed += (target_speed > currentSpeed) ? step : -step;
    }

    return constrain(currentSpeed, TURN_SPEED, 
                    (isPrecisionMode ? SPEED_SLOW : BASE_FAST));
}
```

The marker processing system uses an efficient state machine with four states:

- State 0: No markers detected
- State 1: Left marker only
- State 2: Right marker only
- State 3: Both markers detected

The state machine implementation processes changes only when necessary:

```cpp
void CourseMarkers::processMarkerSignals() {
    readCourseMarkers();

    // Only process on state changes
    if (lastMarkerState == currentMarkerState) {
        return;
    }

    // State machine for marker processing
    switch (currentMarkerState) {
    case 0: // No markers
        if (lastMarkerState == 2 && previousMarkerState == 0) {
            handleFinishLine();
        }
        else if (lastMarkerState == 1 && previousMarkerState == 0) {
            handleSpeedMode();
        }
        else if (lastMarkerState == 3 || previousMarkerState == 3 || 
                 oldMarkerState == 3) {
            handleIntersection();
        }
        break;
    }
    
    // Update state history
    oldMarkerState = previousMarkerState;
    previousMarkerState = lastMarkerState;
    lastMarkerState = currentMarkerState;
}
```

## ProfileManager Implementation

The ProfileManager serves as RobotZero's configuration system for different operating modes, providing two distinct profiles: one optimized for analysis and another for high-speed performance. This implementation is entirely conditional, only compiled when `DEBUG_LEVEL` is greater than `0`, ensuring zero overhead during normal operation.

``` cpp
class ProfileManager {
public:
    // Initialize profile manager
    static void initialize(DebugMode mode);

    // Get current debug mode
    static DebugMode getCurrentMode();

    // Get speed value based on original speed constant
    static uint8_t getSpeedValue(uint8_t defaultSpeed);

    // Get PID parameters
    static float getKP(float defaultValue);
    static float getKD(float defaultValue);
    static float getFilterCoefficient(float defaultValue);

    // Get acceleration parameters
    static uint8_t getAccelerationStep();
    static uint8_t getBrakeStep();
    static uint8_t getTurnSpeed();
    static uint8_t getTurnThreshold();
    static uint8_t getStraightThreshold();
    static uint8_t getBoostDuration();
    static uint8_t getBoostIncrement();

private:
    static DebugMode currentMode;
    static const SpeedProfile* activeProfile;

    static const SpeedProfile ANALYSIS_PROFILE;
    static const SpeedProfile SPEED_PROFILE;

    static void setActiveProfile(DebugMode mode);
    static uint8_t validateSpeed(uint8_t speed);
};
```

The system is built around two predefined profiles, each optimized for specific purposes:

``` cpp
const SpeedProfile ProfileManager::ANALYSIS_PROFILE = {
    // Speed settings - Conservative for analysis
    .speedStop = 0,
    .speedStartup = 60,    // Slower startup
    .speedTurn = 80,       // Careful turns
    .speedBrake = 90,      // Gentle braking
    .speedCruise = 100,    // Moderate cruising
    .speedSlow = 120,      // Moderate slow speed
    .speedFast = 140,      // Moderate fast speed
    .speedBoost = 160,     // Moderate boost
    .speedMax = 180,       // Limited top speed

    // Control parameters - Smooth operation
    .accelerationStep = 15, // Gentle acceleration
    .brakeStep = 40,       // Moderate braking
    .turnSpeed = 80,       // Conservative turns
    .turnThreshold = 50,   // Earlier turn detection
    .straightThreshold = 25, // Stricter straight detection
    .boostDuration = 8,    // Short boost
    .boostIncrement = 15,  // Gentle boost

    // PID parameters - Stable control
    .kProportional = 4.0f,
    .kDerivative = 500.0f,
    .filterCoefficient = 0.5f
};

const SpeedProfile ProfileManager::SPEED_PROFILE = {
    // Speed settings - Aggressive for performance
    .speedStop = 0,
    .speedStartup = 100,   // Quick startup
    .speedTurn = 120,      // Fast turns
    .speedBrake = 140,     // Strong braking
    .speedCruise = 160,    // Fast cruising
    .speedSlow = 180,      // Fast slow mode
    .speedFast = 200,      // High speed
    .speedBoost = 220,     // Strong boost
    .speedMax = 255,       // Maximum speed

    // Control parameters - Performance focused
    .accelerationStep = 35, // Quick acceleration
    .brakeStep = 70,       // Strong braking
    .turnSpeed = 140,      // Fast turns
    .turnThreshold = 40,   // Later turn detection
    .straightThreshold = 15, // Quicker straight detection
    .boostDuration = 12,   // Longer boost
    .boostIncrement = 25,  // Strong boost

    // PID parameters - Aggressive control
    .kProportional = 6.0f,
    .kDerivative = 700.0f,
    .filterCoefficient = 0.7f
};
```

> **Implementation Note:**  
> **TODO**: These variables should be transferred to macros or constexpr's in the configuration layer, maintaining the system's design principles of compile-time optimization and centralized configuration.

The translation between default values and profile-specific values is handled through the `getSpeedValue` method:

``` cpp
uint8_t ProfileManager::getSpeedValue(uint8_t defaultSpeed) {
    if (activeProfile == nullptr) {
        return defaultSpeed;
    }

    // Map original speed constants to profile values
    if (defaultSpeed == SPEED_STOP) return activeProfile->speedStop;
    if (defaultSpeed == SPEED_STARTUP) return activeProfile->speedStartup;
    if (defaultSpeed == SPEED_TURN) return activeProfile->speedTurn;
    if (defaultSpeed == SPEED_BRAKE) return activeProfile->speedBrake;
    if (defaultSpeed == SPEED_CRUISE) return activeProfile->speedCruise;
    if (defaultSpeed == SPEED_SLOW) return activeProfile->speedSlow;
    if (defaultSpeed == SPEED_FAST) return activeProfile->speedFast;
    if (defaultSpeed == SPEED_BOOST) return activeProfile->speedBoost;
    if (defaultSpeed == SPEED_MAX) return activeProfile->speedMax;

    return validateSpeed(defaultSpeed);
}
```

The Analysis Profile is designed for development and testing, with conservative speeds and gentle transitions. It prioritizes stability and predictability over raw speed, making it ideal for collecting performance data and tuning control parameters. All speed values are reduced, acceleration is gentler, and the PID parameters are tuned for stability.

The Speed Profile, in contrast, is optimized for maximum performance. It uses aggressive speed settings, quick transitions, and more responsive control parameters. The PID constants are increased for faster response, and the thresholds are adjusted to maintain control at higher speeds. These profiles have not yet been tested in competition conditions.

The `ProfileManager` ensures smooth operation by validating all speed values and providing fallback behaviour when no profile is active. When DEBUG_LEVEL is 0, the entire `ProfileManager` code is excluded from compilation, maintaining the efficiency of the production code.