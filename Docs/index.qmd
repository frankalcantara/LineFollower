---
title: "Introduction"
---

A line following robot is an autonomous system designed to follow a path marked by a line on the ground. These robots are often considered an entry point into robotics and automation, as they incorporate fundamental concepts of sensor reading, motor control, and real-time decision making. However, while the basic concept might seem simple, developing a high-performance line follower requires control systems, real-time control, speed, acceleration, and jerk management, performance analysis, and the definition and fine-tuning of a PID controller, all of which demand precise calibration.

Named **RobotZero**, this project embodies the concept of starting from zero - both for those beginning their journey in robotics and in homage to DeepMind's AlphaGo Zero. Like its namesake, which learned chess and Go from scratch, achieving mastery through self-play and analysis, RoboTZero is designed to be a foundation for learning through systematic data collection and analysis. Despite its diminutive size and seemingly simple purpose, the robot incorporates  logging and analysis capabilities that transform it from a basic line follower into a platform for understanding robotics fundamentals, control systems, and performance optimization. It represents "zero" not as nothing, but as the essential starting point for building knowledge and expertise in robotics.

## The Platform: Arduino Nano

For the first version, this project, we chose the Arduino Nano [@ArduinoNano] as our main controller specifically for its constrained environment. When we can achieve efficiency and speed within such limitations, we learn how to optimize ideas, algorithms, and programs - skills that are valuable across all computing platforms. The Arduino Nano [@ArduinoNano], based on the ATmega328P microcontroller, [@Microchip_ATmega328P], offers a small form factor (45 x 18 mm), ideal for compact robot designs. It includes 32KB of Flash memory, suitable for our advanced logging system, 2KB of SRAM for runtime operations, and runs at 16MHz, providing adequate processing power. The board features multiple analog inputs for our sensor array, PWM outputs for precise motor control, and maintains low power consumption while being cost-effective for both prototyping and final implementation.

## Project Overview

In most projects, adjusting a line following robot for speed and efficiency becomes a tedious and time-consuming trial-and-error routine. We have observed this adjustment procedure in some competitions and during hundreds of hours of videos on YouTube. Our project addresses this challenge by incorporating an advanced logging and analysis system that transforms the tuning process into a data-driven approach. The robot includes high-precision line detection using a 6-sensor array, PID-based motion control for smooth operation, and dual operating modes for analysis and high-speed performance. The comprehensive data logging system enables real-time performance monitoring, with flash-based storage for post-run analysis and a USB interface for data retrieval and analysis, providing the tools necessary for systematic testing and configuration.

## Why C++?

The choice of C++ as our programming language was deliberate and based on several key factors. C++ allows us to organize our code into logical classes and modules, making the system more maintainable and easier to understand. This is particularly important for complex systems like our logging mechanism. The language provides low-level hardware access while supporting high-level abstractions, crucial for real-time operations where microseconds matter, such as sensor reading and motor control.

With limited resources on the Arduino Nano [@ArduinoNano], C++'s efficient memory management and minimal runtime overhead are essential. We can precisely control memory allocation and ensure optimal use of the available RAM. The language's support for namespaces, classes, and templates helps maintain clean code architecture despite the system's complexity. C++'s strong type system helps catch errors at compile-time rather than runtime, which is crucial for a system that needs to operate autonomously. Additionally, C++ allows us to create clean abstractions over hardware components while maintaining direct access when needed, making the code both maintainable and efficient. The object-oriented features facilitate code reuse and modular design, making it easier to extend or modify the robot's functionality.

The combination of Arduino Nano [@ArduinoNano]'s capabilities with C++'s features allows us to create a  line following robot that not only performs its primary function but also provides valuable insights into its operation through advanced logging and analysis capabilities.