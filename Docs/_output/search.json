[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RobotZero A Comprehensive Environment for Line-Following Robot Development",
    "section": "",
    "text": "0.1 The Platform: Arduino Nano\nFor this project, we chose the Arduino Nano as our main controller specifically for its constrained environment. When we can achieve efficiency and speed within such limitations, we learn how to optimize ideas, algorithms, and programs - skills that are valuable across all computing platforms. The Arduino Nano, based on the ATmega328P microcontroller, offers a small form factor (45 x 18 mm), ideal for compact robot designs. It includes 32KB of Flash memory, suitable for our advanced logging system, 2KB of SRAM for runtime operations, and runs at 16MHz, providing adequate processing power. The board features multiple analog inputs for our sensor array, PWM outputs for precise motor control, and maintains low power consumption while being cost-effective for both prototyping and final implementation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#project-overview",
    "href": "index.html#project-overview",
    "title": "RobotZero A Comprehensive Environment for Line-Following Robot Development",
    "section": "0.2 Project Overview",
    "text": "0.2 Project Overview\nIn most projects, adjusting a line following robot for speed and efficiency becomes a tedious and time-consuming trial-and-error routine. Our project addresses this challenge by incorporating an advanced logging and analysis system that transforms the tuning process into a data-driven approach. The robot includes high-precision line detection using a 6-sensor array, PID-based motion control for smooth operation, and dual operating modes for analysis and high-speed performance. The comprehensive data logging system enables real-time performance monitoring, with flash-based storage for post-run analysis and a USB interface for data retrieval and analysis, providing the tools necessary for systematic testing and configuration.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "RobotZero A Comprehensive Environment for Line-Following Robot Development",
    "section": "0.3 Why C++?",
    "text": "0.3 Why C++?\nThe choice of C++ as our programming language was deliberate and based on several key factors. C++ allows us to organize our code into logical classes and modules, making the system more maintainable and easier to understand. This is particularly important for complex systems like our logging mechanism. The language provides low-level hardware access while supporting high-level abstractions, crucial for real-time operations where microseconds matter, such as sensor reading and motor control.\nWith limited resources on the Arduino Nano, C++’s efficient memory management and minimal runtime overhead are essential. We can precisely control memory allocation and ensure optimal use of the available RAM. The language’s support for namespaces, classes, and templates helps maintain clean code architecture despite the system’s complexity. C++’s strong type system helps catch errors at compile-time rather than runtime, which is crucial for a system that needs to operate autonomously. Additionally, C++ allows us to create clean abstractions over hardware components while maintaining direct access when needed, making the code both maintainable and efficient. The object-oriented features facilitate code reuse and modular design, making it easier to extend or modify the robot’s functionality.\nThe combination of Arduino Nano’s capabilities with C++’s features allows us to create a sophisticated line following robot that not only performs its primary function but also provides valuable insights into its operation through advanced logging and analysis capabilities.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "oper.html",
    "href": "oper.html",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1 Operating Procedure",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "oper.html#operating-procedure",
    "href": "oper.html#operating-procedure",
    "title": "2  Line Following Robot Operation",
    "section": "",
    "text": "2.1.1 Initial Setup\n\nPlace the robot near the course\nPower on the robot\nWait for initial setup delay (600ms)\n\nStatus LED will be on during this period\nMotors will be inactive\n\nAfter delay, LED turns off and robot is ready for calibration\n\n\n\n2.1.2 Calibration Process\n\nPress the start button for first calibration phase\n\nLED will turn on\n\nThe calibration process:\n\nTakes 400 samples from each sensor\n30ms delay between samples (total ~12 seconds)\nEstablishes minimum and maximum values for each sensor\n\nAfter calibration completes:\n\nLED turns off\nRobot waits for second button press\n\n\n\n\n2.1.3 Operation Start\n\nPlace robot on the track\nPress start button again to begin operation\n\nLED turns on\nRobot starts line following operation\n\nInitial operating parameters:\n\nSpeed mode begins at BASE_FAST (115)\nPID control active with default parameters\nNormal operating mode engaged\n\n\n\n\n2.1.4 During Operation\nThe robot recognizes three marker patterns: 1. Finish line marker (both sensors) - Updates lap count - Triggers stop sequence on second detection 2. Speed mode marker (left sensor only) - Toggles between normal and precision mode - In precision mode: SPEED_SLOW - In normal mode: BASE_FAST 3. Intersection marker (both sensors) - Logged but no special action taken\n\n\n2.1.5 Stop Sequence\nThe robot will stop automatically when: 1. Second finish line is detected 2. Stop sequence activates: - Speed reduces to SPEED_BRAKE - After 50ms deceleration - Final stop after 300ms - Motors power off\n\n\n2.1.6 Data Retrieval (Debug Mode Only)\nIf DEBUG_LEVEL &gt; 0: 1. When robot stops, flash memory is marked as ready 2. LED displays transmission pattern: - Alternates between slow blink (1000ms) and fast blink (300ms) - Pattern switches every 3000ms 3. Data can be retrieved through serial interface 4. After successful transmission: - Log ready flag is cleared - LED pattern stops\n\n\n2.1.7 Error Recovery\nIf line is lost: 1. Robot uses last valid position 2. Position is forced to extreme (-100 or 100) based on last direction 3. PID controller attempts to recover 4. Robot continues operation if line is found\n\n\n2.1.8 Operating Modes\nTwo base operating speeds: 1. Normal Mode (BASE_FAST): - Base speed of 115 - Curve speed reduction active - Boost after curves (if not in precision mode)\n\nPrecision Mode:\n\nActivated by left marker\nUses SPEED_SLOW\nDisables boost feature\nMore conservative operation\n\n\nDebug Operating Modes (if DEBUG_LEVEL &gt; 0): 1. Analysis Mode (DEBUG_LEVEL = 1): - 5 laps - Conservative speeds - Full data logging\n\nSpeed Mode (DEBUG_LEVEL = 2):\n\n3 laps\nMaximum performance\nFull data logging",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Line Following Robot Operation</span>"
    ]
  },
  {
    "objectID": "block.html",
    "href": "block.html",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1 Configuration Layer",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#configuration-layer",
    "href": "block.html#configuration-layer",
    "title": "3  RoboZero Modules Description",
    "section": "",
    "text": "3.1.1 config.h\nThe configuration hub of the system, this module defines all crucial parameters including pin assignments, speed settings, and control constants. A notable feature is its use of conditional compilation (#if DEBUG_LEVEL &gt; 0) to ensure zero overhead in normal operation mode, demonstrating our commitment to efficiency.\n\n\n3.1.2 globals.h\nManages global state variables that need to be accessed across different modules. While global variables are generally discouraged, here they serve a crucial role in maintaining real-time performance by avoiding function call overhead for frequently accessed states.\n\n\n3.1.3 debug.h\nImplements a sophisticated debug message system that stores strings in Flash memory instead of RAM, using PROGMEM for optimal memory usage. This approach ensures that debug capabilities don’t impact the robot’s limited RAM resources.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#hardware-interface-layer",
    "href": "block.html#hardware-interface-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.2 Hardware Interface Layer",
    "text": "3.2 Hardware Interface Layer\n\n3.2.1 Sensors\nManages six line sensors and two marker sensors through a calibration-based approach. The unique feature here is the weighted average calculation that provides precise positional data. The system maintains both raw and processed values, enabling real-time adjustments while preserving original readings for analysis.\n\n\n3.2.2 MotorsDrivers\nImplements motor control using PWM, with a key feature being its ability to handle both forward and reverse motion through a single interface. The module includes built-in protection against invalid PWM values, ensuring safe operation even under software errors.\n\n\n3.2.3 Peripherals\nHandles external interfaces including button input and LED status indication. Notable is its debounce implementation that maintains responsiveness while ensuring reliable button detection, essential for both operation and calibration phases.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#control-layer",
    "href": "block.html#control-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.3 Control Layer",
    "text": "3.3 Control Layer\n\n3.3.1 CourseMarkers\nProcesses track markers using a state machine approach to detect different patterns (finish line, speed mode changes, intersections). Its sophisticated detection system can differentiate between various marker combinations while maintaining reliable operation under varying light conditions.\n\n\n3.3.2 ProfileManager\nManages different operation profiles (analysis and speed modes). The key innovation here is its transparent speed value translation system, which allows the same base code to operate under different performance parameters without modification.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#debug-layer",
    "href": "block.html#debug-layer",
    "title": "3  RoboZero Modules Description",
    "section": "3.4 Debug Layer",
    "text": "3.4 Debug Layer\n\n3.4.1 Logger\nImplements a sophisticated logging system using circular buffers to maintain performance. A key feature is its ability to write to flash memory only during straight-line sections, ensuring logging doesn’t interfere with critical control operations.\n\n\n3.4.2 FlashManager\nHandles flash memory operations with built-in error checking and recovery mechanisms. Notable is its page-aligned writing system that maximizes flash memory lifespan while ensuring data integrity.\n\n\n3.4.3 FlashReader\nManages data retrieval through a structured protocol, including checksums for data validation. The module implements a multi-marker system to ensure reliable data transmission even under noisy serial connections.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  },
  {
    "objectID": "block.html#main-control",
    "href": "block.html#main-control",
    "title": "3  RoboZero Modules Description",
    "section": "3.5 Main Control",
    "text": "3.5 Main Control\n\n3.5.1 main.cpp\nThe core control loop implementing PID-based line following. A significant feature is its non-blocking setup sequence that maintains system responsiveness during initialization and calibration. The module seamlessly integrates debug features when compiled with DEBUG_LEVEL &gt; 0 while maintaining optimal performance in normal operation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RoboZero Modules Description</span>"
    ]
  }
]