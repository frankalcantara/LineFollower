# Main Layer Implementation (main.cpp)

The `main.cpp` file serves as the orchestration center for RobotZero, integrating all layers and managing the robot's core operation sequence. The implementation follows a clear state machine pattern during setup and implements a sophisticated control loop for line following.

Setup Phase:
The initialization process follows a non-blocking state machine with seven states:

```cpp
enum SetupState {
   SETUP_INIT,        // Initial system configuration
   SETUP_WAIT1,       // First stabilization delay
   SETUP_WAIT2,       // Second stabilization delay
   SETUP_BUTTON1,     // Wait for first button press
   SETUP_CALIBRATION, // Sensor calibration sequence
   SETUP_BUTTON2,     // Wait for start signal
   SETUP_COMPLETE     // System ready
};
```

Each state ensures proper system initialization without blocking operations. This is particularly important for sensor stabilization and user interaction.

**Control Parameters**: The main loop maintains critical control variables:

```cpp
// Control parameters
int targetLinePosition = POSICION_IDEAL_DEFAULT;
float kProportional = K_PROPORTIONAL_DEFAULT;
float kDerivative = K_DERIVATIVE_DEFAULT;
float filterCoefficient = FILTER_COEFFICIENT_DEFAULT;
int filteredErrorRate = 0;
int previousError = 0;
```

The main control loop implements a sophisticated PID control system with filtered derivative action:

```cpp
void loop() {
#if DEBUG_LEVEL > 0
   LedPattern::process();
#endif

   CourseMarkers::processMarkerSignals();

   if (isRobotStopped) {
       MotorDriver::setMotorsPower(0, 0);
#if DEBUG_LEVEL > 0
       if (Logger::isLogging()) {
           Logger::endSession();
       }
#endif
       return;
   }

   // Position and error calculation
   int linePosition = Sensors::calculateLinePosition();
   int error = linePosition - targetLinePosition;

   // Speed control based on error
#if DEBUG_LEVEL > 0
   currentSpeed = ProfileManager::getSpeedValue(CourseMarkers::speedControl(error));
#else
   currentSpeed = CourseMarkers::speedControl(error);
#endif

   // Error derivative calculation and filtering
   int d_error = error - previousError;
   filteredErrorRate = filterCoefficient * d_error + 
                      (1 - filterCoefficient) * filteredErrorRate;

   // PID correction calculation
   float proportional_term = kProportional * error;
   float derivative_term = kDerivative * filteredErrorRate;
   float total_correction = proportional_term + derivative_term;

   // Speed adjustment for high velocities
   float speed_factor = (currentSpeed > 200) ? 0.85f : 1.0f;
   int correction_power = constrain(int(total_correction * speed_factor), -255, 255);

   // Motor power application
   int left_power = constrain(currentSpeed + correction_power, -255, 255);
   int right_power = constrain(currentSpeed - correction_power, -255, 255);

   MotorDriver::setMotorsPower(left_power, right_power);
   previousError = error;

   // Debug data logging
#if DEBUG_LEVEL > 0
   if (Logger::isLogging()) {
       uint8_t state = 0;
       if (isPrecisionMode) state |= 0x01;
       if (abs(error) > TURN_THRESHOLD) state |= 0x02;

       Logger::logPerformance(linePosition, error, correction_power,
           left_power, right_power, state);
       Logger::process();
   }
#endif
}
```

The main loop's architecture provides a integration of RobotZero's various subsystems. At its core, the loop continuously polls system states rather than waiting for events, ensuring smooth operation without any blocking delays. This polling approach allows the robot to respond immediately to line position changes, marker detections, and user inputs while maintaining precise timing for control calculations.

The implementation uses preprocessor directives (`#if DEBUG_LEVEL > 0`) to seamlessly integrate debugging capabilities without impacting normal performance. When debug mode is active, the loop incorporates additional data collection and LED pattern processing, but these operations are completely removed from the compiled code in production mode, ensuring zero overhead during competitions.

The control system implements a PID controller with special attention to derivative filtering. Rather than using raw error differences, which can amplify sensor noise, the system employs an exponential filter (`filteredErrorRate`) that smooths the derivative term while maintaining responsive control. This filtering approach is particularly crucial during high-speed operation where sensor noise could cause unstable behaviour.

Motor control calculations incorporate a sophisticated speed-based correction scaling. When operating at high speeds (above 200 PWM), the system automatically reduces the correction factor to 85%, preventing overcorrection that could lead to oscillations. This adaptive approach allows aggressive corrections at lower speeds while maintaining stability during high-speed straight-line runs.

The motor power management system implements bidirectional control with careful attention to power constraints. All motor commands are processed through the `constrain()` function, ensuring values remain within the valid PWM range (-255 to +255). The differential drive calculations (`currentSpeed Â± correction_power`) provide smooth transitions between straight-line tracking and turning manurers.

In debug mode, the system maintains detailed operational records without impacting control timing. The loop captures comprehensive performance data including line position, calculated error, applied corrections, and motor powers. Additionally, it tracks system states like precision mode activation and curve detection through bitwise flags, providing detailed context for post-run analysis. This data collection system operates in parallel with the control calculations, maintaining microsecond-level timing precision while accumulating valuable debugging information.

This integrated approach results in a control system that maintains precise line following across a wide range of speeds while providing deep insight into system behaviour when needed for optimization or troubleshooting.

#### Line Following Robot Control Theory vs Implementation

The theoretical approach for line following control focuses on developing a control law that adjusts the robot's direction to minimize lateral error $e$. The system dynamics are described by:

$$
\dot{e} = v \sin \alpha
$$

Where:

- $e$ is the lateral error relative to the desired trajectory;
- $v$ is the robot's linear velocity;
- $\alpha$ is the angle between the robot's direction and desired trajectory.

Taking the time derivative:

$$
\ddot{e} = v \dot{\alpha} \cos \alpha
$$

For most line following scenarios, we can approximate the orientation error rate $\alpha$ to be approximately equal to the robot's angular velocity $\omega$:

$$
\dot{\alpha} \approx \omega
$$

Therefore:

$$
\ddot{e} = v \omega \cos \alpha
$$

To linearize this nonlinear system, we introduce a new control variable $\eta$:

$$
\eta = v \omega \cos \alpha
$$

This transforms our system into:

$$
\ddot{e} = \eta
$$

This linear second-order system allows for a PID control law:

$$
\eta = -K_p e - K_d \dot{e} - K_i \int e \, dt
$$

The angular velocity $\omega$ can then be derived:

$$
\omega = \frac{\eta}{v \cos \alpha}
$$

For small angles, we can simplify to:

$$
\omega = \frac{\eta}{v}
$$

Implementation Constraints:

While this control approach provides superior theoretical performance, practical implementation on RobotZero's Arduino Nano ([@ArduinoNano]) platform would require: 

1. Flash Memory: Additional `~30%` (`~8KB`) for enhanced control algorithms and sensor processing;
2. RAM: ~15% increase (`~300 bytes`) for additional state variables and calculations;
3. Processing Time: Doubled control loop duration due to complex mathematical operations.

These requirements exceed available resources on the Arduino Nano ([@ArduinoNano]) platform. Therefore, RobotZero implements a simplified PID variant that maintains acceptable performance while operating within hardware constraints:

```cpp
float proportional_term = kProportional * error;
float derivative_term = kDerivative * filteredErrorRate;
float total_correction = proportional_term + derivative_term;
```

#### Adding Integral Control Analysis

To implement integral control in RobotZero's current architecture, we would need relatively minor modifications compared to the full theoretical model. Here's the analysis:

Code Modifications Required:

1. Add integral term to control variables:
   
```cpp
// Control parameters - add to main.cpp
float kIntegral = K_INTEGRAL_DEFAULT;    // Integral gain
float integralError = 0;                 // Accumulated error
float integralLimit = 200.0f;            // Anti-windup limit
```

1. Modify the main control loop:
   
    ```cpp
    // In main loop, after error calculation
    integralError += error * loopInterval;  // Loop interval in seconds

    // Anti-windup protection
    integralError = constrain(integralError, -integralLimit, integralLimit);

    // PID correction calculation
    float proportional_term = kProportional * error;
    float derivative_term = kDerivative * filteredErrorRate;
    float integral_term = kIntegral * integralError;
    float total_correction = proportional_term + derivative_term + integral_term;
    ```

    In PID control systems, integral windup (or reset windup) is a serious problem that occurs when the integral term accumulates larger error than the system can physically correct. This situation typically happens when the actuator reaches its physical limits (saturation), but the integral term continues to accumulate error. For example, in RobotZero's case:

       - The motors have a maximum `PWM` value of `255`;
       - If the robot is far from the line, the error is large;
       - The integral term keeps accumulating this error;
       - Even if the robot returns to the line, the accumulated integral term remains large;
       - This causes significant overshoot and oscillation;

    Consider this scenario:

    1. Robot loses the line (large error);
    2. Without anti-windup: integral term keeps growing indefinitely;
    3. When line is found again, the huge integral term causes the robot to overshoot;
    4. This leads to oscillations or even complete loss of control.

    The anti-windup protection:

2. Add configuration constant:
   
    ```cpp
    // In config.h
    static constexpr float K_INTEGRAL_DEFAULT = 0.1f;
    ```

3. Update ProfileManager for debug modes:

    ```cpp
    struct SpeedProfile {
    // Existing members...
    float kIntegral;            // Add integral gain
    };
    ```

4. Resource Impact:
   
   - Flash Memory: `~100 bytes` (negligible increase)
   - RAM: `8 bytes` (`2 floats`: integralError and integralLimit)
   - Processing Time: `<5% `increase per control loop

Debug System Impact:

1. Expand PerformanceRecord:

    ```cpp
    struct PerformanceRecord {
    // Existing members...
    float integralTerm;    // Add if detailed analysis needed
    };
    ```

The implementation of integral control represents a modest addition to RobotZero's existing architecture. The system requires no additional hardware components to function, allowing us to maintain the current sensor and motor configuration. Memory utilization remains efficient, requiring only eight bytes of RAM for the integral accumulator and limit values, while the flash memory increase is negligible at approximately 100 bytes. The mathematical computations involved - primarily addition for accumulation and a single multiplication for the integral term - introduce minimal computational overhead to the control loop. Furthermore, the existing control structure accommodates this addition naturally, as the integral term simply extends the current proportional and derivative calculations without requiring architectural changes.

While implementing the integral term itself is straightforward, the real challenge lies in the calibration process. Tuning three interconnected gains - proportional, integral, and derivative - requires more sophisticated calibration procedures than the current two-gain system. Each gain affects the others, creating a more complex optimization problem. However, this calibration complexity represents a one-time configuration challenge rather than an ongoing resource constraint, making it a worthwhile trade-off for the improved steady-state error elimination that integral control provides.